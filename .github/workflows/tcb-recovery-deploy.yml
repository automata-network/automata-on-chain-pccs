name: TCB Recovery Deploy

on:
  issues:
    types: [closed]

permissions:
  contents: write
  pull-requests: write

jobs:
  deploy:
    if: >-
      (!github.event.issue.state_reason || github.event.issue.state_reason == 'completed') &&
      github.event.issue.user.login == 'github-actions[bot]' &&
      startsWith(github.event.issue.title, 'Missing Deployment Found') &&
      contains(github.event.issue.labels.*.name, 'tcb-recovery-missing-deployment')
    runs-on: ubuntu-latest
    environment: tcb-deploy

    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # pinned from v6

      - name: Validate issue label
        id: validate
        env:
          ISSUE_LABELS_JSON: ${{ toJson(github.event.issue.labels.*.name) }}
        run: |
          has_label=$(jq -r 'index("tcb-recovery-missing-deployment") != null' <<<"$ISSUE_LABELS_JSON")
          echo "has_label=$has_label" >> "$GITHUB_OUTPUT"

      - name: Parse checked contracts from issue body
        id: parse
        if: steps.validate.outputs.has_label == 'true'
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          chmod +x .github/scripts/parse_issue_checklist.sh

          printf '%s\n' "$ISSUE_BODY" > issue-body.md
          .github/scripts/parse_issue_checklist.sh issue-body.md > checked-deployments.json

          selected_count=$(jq 'length' checked-deployments.json)
          echo "selected_count=$selected_count" >> "$GITHUB_OUTPUT"

      - name: Install Foundry
        if: steps.validate.outputs.has_label == 'true' && steps.parse.outputs.selected_count != '0'
        uses: foundry-rs/foundry-toolchain@8789b3e21e6c11b2697f5eb56eddae542f746c10 # pinned from v1
      
      - name: Run Forge build
        if: steps.validate.outputs.has_label == 'true' && steps.parse.outputs.selected_count != '0'
        run: |
          forge --version
          forge build --sizes
        id: build

      - name: Execute checked deployments
        id: execute
        if: steps.validate.outputs.has_label == 'true' && steps.parse.outputs.selected_count != '0'
        env:
          CHAIN_RPC_URL_MAP: ${{ secrets.CHAIN_RPC_URL_MAP }}
          DEPLOYER_PRIVATE_KEY: ${{ secrets.DEPLOYER_PRIVATE_KEY }}
          DEPLOYER_KEYSTORE_BASE64: ${{ secrets.DEPLOYER_KEYSTORE_BASE64 }}
          DEPLOYER_KEYSTORE_PASSWORD: ${{ secrets.DEPLOYER_KEYSTORE_PASSWORD }}
        run: |
          set -euo pipefail

          if [ -z "${CHAIN_RPC_URL_MAP:-}" ]; then
            echo "CHAIN_RPC_URL_MAP secret is required (JSON map keyed by chain ID)."
            exit 1
          fi

          wallet_args=()
          owner=""

          if [ -n "${DEPLOYER_PRIVATE_KEY:-}" ]; then
            owner="$(cast wallet address --private-key "$DEPLOYER_PRIVATE_KEY")"
            wallet_args=(--private-key "$DEPLOYER_PRIVATE_KEY")
          elif [ -n "${DEPLOYER_KEYSTORE_BASE64:-}" ] && [ -n "${DEPLOYER_KEYSTORE_PASSWORD:-}" ]; then
            keystore_path="$RUNNER_TEMP/deployer-keystore.json"
            printf '%s' "$DEPLOYER_KEYSTORE_BASE64" | base64 --decode > "$keystore_path"
            owner="$(cast wallet address --keystore "$keystore_path" --password "$DEPLOYER_KEYSTORE_PASSWORD")"
            wallet_args=(--keystore "$keystore_path" --password "$DEPLOYER_KEYSTORE_PASSWORD")
          else
            echo "Configure DEPLOYER_PRIVATE_KEY or DEPLOYER_KEYSTORE_BASE64 + DEPLOYER_KEYSTORE_PASSWORD."
            exit 1
          fi

          echo '[]' > deploy-results.json
          has_failures=false

          record_result() {
            local cid="$1" net="$2" tcb="$3" key="$4" st="$5" err="$6"
            jq -c \
              --arg cid "$cid" --arg net "$net" --argjson tcb "$tcb" \
              --arg key "$key" --arg st "$st" --arg err "$err" \
              '. += [{ chain_id: $cid, network: $net, tcb: $tcb, deploy_key: $key, status: $st, error: $err }]' \
              deploy-results.json > deploy-results.tmp && mv deploy-results.tmp deploy-results.json
          }

          while IFS= read -r item; do
            chain_id="$(jq -r '.chain_id' <<<"$item")"
            network="$(jq -r '.network' <<<"$item")"
            tcb_number="$(jq -r '.tcb' <<<"$item")"
            contract_name="$(jq -r '.contract' <<<"$item")"

            # Determine deploy_key and sig first so all failure paths can reference them
            case "$contract_name" in
              AutomataEnclaveIdentityDaoVersioned.sol)
                deploy_key="AutomataEnclaveIdentityDaoVersioned_tcbeval_${tcb_number}"
                sig='deployEnclaveIdDaoVersioned(uint32)'
                ;;
              AutomataFmspcTcbDaoVersioned.sol)
                deploy_key="AutomataFmspcTcbDaoVersioned_tcbeval_${tcb_number}"
                sig='deployFmspcTcbDaoVersioned(uint32)'
                ;;
              *)
                echo "::error::Unsupported contract in issue checklist: $contract_name"
                record_result "$chain_id" "$network" "$tcb_number" "$contract_name" "failed" "Unsupported contract: $contract_name"
                has_failures=true
                continue
                ;;
            esac

            rpc_url="$(jq -r --arg id "$chain_id" '.[$id] // empty' <<<"$CHAIN_RPC_URL_MAP")"
            if [ -z "$rpc_url" ]; then
              echo "::error::Missing RPC URL in CHAIN_RPC_URL_MAP for chain ID $chain_id"
              record_result "$chain_id" "$network" "$tcb_number" "$deploy_key" "failed" "Missing RPC URL for chain $chain_id"
              has_failures=true
              continue
            fi

            if ! resolved_chain_id="$(cast chain-id --rpc-url "$rpc_url" 2>&1)"; then
              echo "::error::Failed to query chain ID from RPC for chain $chain_id: $resolved_chain_id"
              record_result "$chain_id" "$network" "$tcb_number" "$deploy_key" "failed" "cast chain-id failed for chain $chain_id"
              has_failures=true
              continue
            fi
            if [ "$resolved_chain_id" != "$chain_id" ]; then
              echo "::error::RPC URL chain mismatch for chain $chain_id (resolved $resolved_chain_id)"
              record_result "$chain_id" "$network" "$tcb_number" "$deploy_key" "failed" "Chain ID mismatch: expected $chain_id, got $resolved_chain_id"
              has_failures=true
              continue
            fi

            deployment_file="deployment/${chain_id}.json"
            if [ ! -f "$deployment_file" ]; then
              echo "::error::Missing deployment file: $deployment_file"
              record_result "$chain_id" "$network" "$tcb_number" "$deploy_key" "failed" "Missing deployment file: $deployment_file"
              has_failures=true
              continue
            fi

            if jq -e --arg key "$deploy_key" 'has($key) and .[$key] != null and .[$key] != ""' "$deployment_file" >/dev/null; then
              echo "Skipping already deployed ${deploy_key} on chain ${chain_id}"
              record_result "$chain_id" "$network" "$tcb_number" "$deploy_key" "skipped" ""
              continue
            fi

            echo "Deploying ${contract_name} for TCB ${tcb_number} on chain ${chain_id}"
            export RPC_URL="$rpc_url"
            if forge_output="$(OWNER="$owner" forge script script/automata/versioned/DeployAutomataVersioned.s.sol:DeployAutomataVersioned \
              --rpc-url "$RPC_URL" \
              "${wallet_args[@]}" \
              --broadcast --skip-simulation -vv \
              --sig "$sig" "$tcb_number" 2>&1)"; then
              echo "$forge_output"
              record_result "$chain_id" "$network" "$tcb_number" "$deploy_key" "completed" ""
            else
              echo "$forge_output"
              echo "::error::forge script failed for ${deploy_key} on chain ${chain_id}"
              record_result "$chain_id" "$network" "$tcb_number" "$deploy_key" "failed" "forge script failed for ${deploy_key} on chain ${chain_id}"
              has_failures=true
            fi
          done < <(jq -c '.[]' checked-deployments.json)

          if git diff --quiet -- deployment; then
            echo "changes=false" >> "$GITHUB_OUTPUT"
          else
            echo "changes=true" >> "$GITHUB_OUTPUT"
          fi

          if [ "$has_failures" = true ]; then
            echo "::warning::One or more deployments failed. See deployment summary for details."
            exit 1
          fi

      - name: Write deployment summary
        if: always() && steps.validate.outputs.has_label == 'true' && steps.parse.outputs.selected_count != '0'
        run: |
          set -euo pipefail

          if [ ! -f deploy-results.json ]; then
            echo "# Deployment Summary" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "⚠️ No deployment results file found. The workflow may have failed before deployments started." >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          results="$(cat deploy-results.json)"
          result_count="$(jq 'length' <<<"$results")"

          echo "# Deployment Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          if [ "$result_count" -eq 0 ]; then
            echo "No new contracts were deployed." >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          for chain_id in $(jq -r '[.[].chain_id] | unique | sort_by(tonumber) | .[]' <<<"$results"); do
            network="$(jq -r --arg cid "$chain_id" '[.[] | select(.chain_id == $cid)][0].network' <<<"$results")"
            echo "## ${network} (Chain ID: ${chain_id})" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "| Contract Name | TCB Eval Data Number | Address | Status |" >> "$GITHUB_STEP_SUMMARY"
            echo "| --- | --- | --- | --- |" >> "$GITHUB_STEP_SUMMARY"

            deployment_file="deployment/${chain_id}.json"

            while IFS= read -r row; do
              tcb="$(jq -r '.tcb' <<<"$row")"
              deploy_key="$(jq -r '.deploy_key' <<<"$row")"
              status="$(jq -r '.status' <<<"$row")"
              error="$(jq -r '.error' <<<"$row")"
              contract_name="${deploy_key%%_tcbeval_*}"

              case "$status" in
                completed)
                  if [ -f "$deployment_file" ]; then
                    address="$(jq -r --arg key "$deploy_key" '.[$key] // "—"' "$deployment_file")"
                  else
                    address="—"
                  fi
                  status_display="✅ Completed"
                  ;;
                failed)
                  address="$error"
                  status_display="❌ Failed"
                  ;;
                skipped)
                  address="Already deployed"
                  status_display="⏭️ Skipped"
                  ;;
                *)
                  address="—"
                  status_display="Unknown"
                  ;;
              esac

              echo "| ${contract_name} | ${tcb} | \`${address}\` | ${status_display} |" >> "$GITHUB_STEP_SUMMARY"
            done < <(jq -c --arg cid "$chain_id" '.[] | select(.chain_id == $cid)' <<<"$results")

            echo "" >> "$GITHUB_STEP_SUMMARY"
          done

          completed_count="$(jq '[.[] | select(.status == "completed")] | length' <<<"$results")"
          failed_count="$(jq '[.[] | select(.status == "failed")] | length' <<<"$results")"
          skipped_count="$(jq '[.[] | select(.status == "skipped")] | length' <<<"$results")"
          echo "**Results**: ${completed_count} completed, ${failed_count} failed, ${skipped_count} skipped" >> "$GITHUB_STEP_SUMMARY"

      - name: Clean up temporary files
        if: always() && steps.validate.outputs.has_label == 'true' && steps.parse.outputs.selected_count != '0'
        run: rm -f checked-deployments.json deploy-results.json issue-body.md

      - name: Create deployment pull request
        id: cpr
        if: always() && steps.execute.outputs.changes == 'true'
        uses: peter-evans/create-pull-request@c0f553fe549906ede9cf27b5156039d195d2ece0 # pinned from v8
        with:
          branch: deployment/issue-${{ github.event.issue.number }}
          commit-message: "chore: deployment updates from issue #${{ github.event.issue.number }}"
          title: "Deployment updates from issue #${{ github.event.issue.number }}"
          body: |
            Automated deployment updates for checked contracts in issue #${{ github.event.issue.number }}.
          base: main
          labels: deployment

      - name: No checked contracts
        if: steps.validate.outputs.has_label == 'true' && steps.parse.outputs.selected_count == '0'
        run: echo "Issue closed with no checked contracts. Nothing to deploy."
